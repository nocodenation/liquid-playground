import json
import base64
from nifiapi.flowfilesource import FlowFileSource, FlowFileSourceResult
from nifiapi.properties import PropertyDescriptor, StandardValidators, ExpressionLanguageScope

try:
    import msal
    import requests
except ImportError:
    msal = None
    requests = None

class GetMicrosoftMail(FlowFileSource):
    class Java:
        implements = ['org.apache.nifi.python.processor.FlowFileSource']

    class ProcessorDetails:
        version = '0.0.1-SNAPSHOT'
        description = """Fetches emails from a Microsoft 365 / Outlook account using the Microsoft Graph API. 
        Requires a 'token.json' file generated by the MicrosoftOAuthManager processor, containing the refresh token and client configuration."""
        tags = ['microsoft', 'graph', 'email', 'outlook', 'fetch', 'python']
        dependencies = ['msal', 'requests']

    def __init__(self, **kwargs):
        self.app = None
        self.token_data = None
        self.config = None
        self.access_token = None

    TOKEN_FILE = PropertyDescriptor(
        name="Token File Path",
        description="Path to the JSON file containing the OAuth2 tokens and configuration (generated by MicrosoftOAuthManager).",
        required=True,
        validators=[StandardValidators.FILE_EXISTS_VALIDATOR],
        expression_language_scope=ExpressionLanguageScope.ENVIRONMENT
    )

    FOLDER_ID = PropertyDescriptor(
        name="Folder ID",
        description="The Mail Folder to retrieve messages from. 'Inbox' is the default well-known name.",
        required=True,
        default_value="Inbox",
        validators=[StandardValidators.NON_EMPTY_VALIDATOR]
    )

    FILTER_QUERY = PropertyDescriptor(
        name="Filter Query",
        description="OData $filter query to filter messages. Example: 'isRead eq false'.",
        required=False,
        default_value="isRead eq false",
        validators=[StandardValidators.NON_EMPTY_VALIDATOR]
    )

    MARK_READ = PropertyDescriptor(
        name="Mark as Read",
        description="If true, messages will be marked as read after fetching.",
        required=True,
        default_value="true",
        validators=[StandardValidators.BOOLEAN_VALIDATOR]
    )

    OUTPUT_FORMAT = PropertyDescriptor(
        name="Output Format",
        description="The format of the output FlowFile content.",
        required=True,
        default_value="JSON",
        allowable_values=["JSON", "RAW"],
        validators=[StandardValidators.NON_EMPTY_VALIDATOR]
    )

    def getPropertyDescriptors(self):
        return [self.TOKEN_FILE, self.FOLDER_ID, self.FILTER_QUERY, self.MARK_READ, self.OUTPUT_FORMAT]

    def onScheduled(self, context):
        if msal is None or requests is None:
            self.logger.error("Required libraries not found. Please ensure requirements.txt is installed.")
            return

        token_path = context.getProperty(self.TOKEN_FILE).evaluateAttributeExpressions().getValue()
        
        try:
            self.logger.info(f"Loading token data from {token_path}")
            with open(token_path, 'r') as f:
                data = json.load(f)
            
            self.config = data.get("configuration")
            self.token_data = data.get("token_data")
            
            if not self.config or not self.token_data:
                self.logger.error("Invalid token file format. Missing configuration or token_data.")
                self.app = None
                return

            # Initialize MSAL App
            authority = f"https://login.microsoftonline.com/{self.config.get('tenant_id')}"
            self.app = msal.ConfidentialClientApplication(
                self.config.get('client_id'),
                authority=authority,
                client_credential=self.config.get('client_secret')
            )
            
            # Initial refresh to ensure we have a valid access token
            self._refresh_token()
            
        except Exception as e:
            self.logger.error(f"Failed to initialize Microsoft Graph client: {str(e)}")
            self.app = None

    def _refresh_token(self):
        if not self.app or not self.token_data:
            return False
            
        # Try to acquire token silently using the refresh token from the saved data
        # The 'token_data' from acquire_token_by_authorization_code contains the refresh_token
        
        # Note: acquire_token_by_refresh_token expects just the string, not the whole dict usually,
        # but let's check msal python docs.
        # app.acquire_token_by_refresh_token(refresh_token, scopes=None)
        
        refresh_token = self.token_data.get('refresh_token')
        if not refresh_token:
            self.logger.error("No refresh token found in token data.")
            return False
            
        scopes = self.config.get('scopes', ["User.Read", "Mail.ReadWrite"])
        
        result = self.app.acquire_token_by_refresh_token(
            refresh_token,
            scopes=scopes
        )
        
        if "error" in result:
            self.logger.error(f"Failed to refresh token: {result.get('error_description')}")
            return False
        
        # Update current token data
        self.token_data = result
        self.access_token = result.get('access_token')
        self.logger.info("Successfully refreshed access token.")
        return True

    def create(self, context):
        if not self.app or not self.access_token:
            # Try to re-initialize
            self.onScheduled(context)
            if not self.app or not self.access_token:
                return None

        try:
            folder_id = context.getProperty(self.FOLDER_ID).getValue()
            filter_query = context.getProperty(self.FILTER_QUERY).getValue()
            
            # Graph API Endpoint
            url = f"https://graph.microsoft.com/v1.0/me/mailFolders/{folder_id}/messages"
            
            params = {
                "$top": 1, # Fetch one at a time
                "$select": "id,subject,from,toRecipients,receivedDateTime,body,isRead,internetMessageId,hasAttachments"
            }
            
            if filter_query:
                params["$filter"] = filter_query
                
            headers = {
                "Authorization": f"Bearer {self.access_token}",
                "Content-Type": "application/json"
            }
            
            response = requests.get(url, headers=headers, params=params)
            
            if response.status_code == 401:
                self.logger.info("Access token expired or invalid. Attempting refresh.")
                if self._refresh_token():
                    # Retry once
                    headers["Authorization"] = f"Bearer {self.access_token}"
                    response = requests.get(url, headers=headers, params=params)
                else:
                    return None
            
            if response.status_code != 200:
                self.logger.error(f"Failed to fetch messages. Status: {response.status_code}, Body: {response.text}")
                return None
                
            data = response.json()
            messages = data.get("value", [])
            
            if not messages:
                return None
                
            msg = messages[0]
            msg_id = msg.get("id")
            
            # Create Attributes
            attributes = {
                "ms.graph.id": msg_id,
                "ms.graph.internetMessageId": msg.get("internetMessageId", ""),
                "email.subject": msg.get("subject", ""),
                "email.date": msg.get("receivedDateTime", ""),
                "mime.type": "application/json"
            }
            
            sender = msg.get("from", {}).get("emailAddress", {})
            if sender:
                attributes["email.from"] = sender.get("address", "")
                attributes["email.from.name"] = sender.get("name", "")

            # Content (Body)
            output_format = context.getProperty(self.OUTPUT_FORMAT).getValue()
            
            if output_format == "RAW":
                # Fetch MIME content
                mime_url = f"https://graph.microsoft.com/v1.0/me/messages/{msg_id}/$value"
                mime_response = requests.get(mime_url, headers=headers)
                
                if mime_response.status_code == 200:
                    content_output = mime_response.content # bytes
                    attributes["mime.type"] = "message/rfc822"
                else:
                    self.logger.error(f"Failed to fetch MIME content. Status: {mime_response.status_code}")
                    # Fallback to JSON or return None?
                    # Let's error out for now to be safe
                    return None
            else:
                # JSON format
                # Graph API returns body as object {contentType: "html", content: "..."}
                # We dump the whole message object
                content_output = json.dumps(msg, indent=2)
                attributes["mime.type"] = "application/json"
            
            # Mark as Read
            if context.getProperty(self.MARK_READ).asBoolean():
                update_url = f"https://graph.microsoft.com/v1.0/me/messages/{msg_id}"
                update_payload = {"isRead": True}
                update_response = requests.patch(update_url, headers=headers, json=update_payload)
                if update_response.status_code != 200:
                     self.logger.warn(f"Failed to mark message as read: {update_response.status_code}")

            return FlowFileSourceResult(relationship="success", attributes=attributes, contents=content_output)

        except Exception as e:
            self.logger.error(f"Error processing Microsoft Mail: {str(e)}")
            return None
