import json
import os
import base64
from nifiapi.flowfilesource import FlowFileSource, FlowFileSourceResult
from nifiapi.properties import PropertyDescriptor, StandardValidators, ExpressionLanguageScope

# Attempt to import Google libraries. 
# These will be available if the requirements.txt is processed correctly.
try:
    from google.oauth2.credentials import Credentials
    from googleapiclient.discovery import build
    from google.auth.transport.requests import Request
except ImportError:
    Credentials = None
    build = None
    Request = None

class GetGoogleMail(FlowFileSource):
    class Java:
        implements = ['org.apache.nifi.python.processor.FlowFileSource']

    class ProcessorDetails:
        version = '0.0.1-SNAPSHOT'
        description = """Fetches emails from a Gmail account using the Google Mail API. 
Requires a 'token.json' file containing a valid OAuth2 Refresh Token. 
This file is typically generated by running a local Python script with the 'google-auth-oauthlib' library to perform the initial user authorization."""
        tags = ['google', 'gmail', 'email', 'fetch', 'python']
        dependencies = ['google-api-python-client', 'google-auth-oauthlib', 'google-auth-httplib2']

    def __init__(self, **kwargs):
        self.service = None

    TOKEN_FILE = PropertyDescriptor(
        name="Token File Path",
        description="Path to the JSON file containing the OAuth2 tokens (client_id, client_secret, refresh_token).",
        required=True,
        validators=[StandardValidators.FILE_EXISTS_VALIDATOR],
        expression_language_scope=ExpressionLanguageScope.ENVIRONMENT
    )

    QUERY = PropertyDescriptor(
        name="Search Query",
        description="Gmail search query to filter messages. Example: 'is:unread label:INBOX'",
        required=True,
        default_value="is:unread",
        validators=[StandardValidators.NON_EMPTY_VALIDATOR]
    )

    MARK_READ = PropertyDescriptor(
        name="Mark as Read",
        description="If true, the 'UNREAD' label will be removed from fetched messages.",
        required=True,
        default_value="true",
        validators=[StandardValidators.BOOLEAN_VALIDATOR]
    )

    OUTPUT_FORMAT = PropertyDescriptor(
        name="Output Format",
        description="The format of the output FlowFile content.",
        required=True,
        default_value="JSON",
        allowable_values=["JSON", "RAW"],
        validators=[StandardValidators.NON_EMPTY_VALIDATOR]
    )

    def getPropertyDescriptors(self):
        return [self.TOKEN_FILE, self.QUERY, self.MARK_READ, self.OUTPUT_FORMAT]

    def onScheduled(self, context):
        if Credentials is None:
            self.logger.error("Google libraries not found. Please ensure requirements.txt is installed.")
            return

        token_path = context.getProperty(self.TOKEN_FILE).evaluateAttributeExpressions().getValue()
        
        try:
            self.logger.info(f"Loading credentials from {token_path}")
            # Load credentials from the token file
            # The file is expected to be in the format generated by google-auth-oauthlib (ClientConfig + tokens)
            # Or a simple dictionary with the necessary fields for google.oauth2.credentials.Credentials
            
            # We'll assume standard "token.json" structure
            self.creds = Credentials.from_authorized_user_file(token_path, ['https://www.googleapis.com/auth/gmail.modify'])
            
            # Refresh if expired (though the library usually handles this on request, it's good to check)
            if self.creds.expired and self.creds.refresh_token:
                self.logger.info("Credentials expired, refreshing...")
                self.creds.refresh(Request())

            self.service = build('gmail', 'v1', credentials=self.creds)
            self.logger.info("Successfully connected to Gmail API")
            
        except Exception as e:
            self.logger.error(f"Failed to initialize Gmail service: {str(e)}")
            # We don't raise here to avoid crash loops, but the processor won't work
            self.service = None

    def create(self, context):
        if self.service is None:
             # Try to re-initialize if it failed previously (or wait for next schedule)
             self.onScheduled(context)
             if self.service is None:
                 return None

        try:
            query = context.getProperty(self.QUERY).getValue()
            # We only process ONE message per execution to return a single FlowFileSourceResult
            # We keep the batch_size property but currently use it as 1 for now, or implement a state manager to iterate.
            # However, FlowFileSource expects a SINGLE FlowFileSourceResult.
            # If we want to support multiple, we have to iterate internally or change approach.
            # But typically a source creates ONE flowfile per call or returns None.
            # Wait! Documentation says: "The return value of the transform method must be a FlowFileTransformResult object."
            # For Source: "The return value of the create method must be a FlowFileSourceResult object."
            # It does NOT say a list is supported. The error confirms this: 'list' object has no attribute '_get_object_id'.
            
            # Strategy: We will fetch only 1 message at a time.
            # To make this efficient, we should really use state management, but for a simple implementation:
            # We fetch 1 message. If we want more, the processor will be triggered again immediately if we yield appropriately?
            # No, if we return a result, it is "Success".
            
            # Let's fetch 1 message
            # Note: fetching only 1 is inefficient for quota, but "GetGoogleMail" implies getting *new* mail.
            # We are using 'is:unread' as default.
            
            results = self.service.users().messages().list(userId='me', q=query, maxResults=1).execute()
            messages = results.get('messages', [])

            if not messages:
                context.yield_()
                return None

            msg = messages[0]
            msg_id = msg['id']
            output_format = context.getProperty(self.OUTPUT_FORMAT).getValue()
            mark_read = context.getProperty(self.MARK_READ).asBoolean()

            # Fetch full message details
            fetch_format = 'raw' if output_format == 'RAW' else 'full'
            message_details = self.service.users().messages().get(userId='me', id=msg_id, format=fetch_format).execute()

            content = ""
            attributes = {
                "gmail.id": msg_id,
                "gmail.threadId": msg['threadId']
            }

            if output_format == "RAW":
                # 'raw' field is base64url encoded string
                raw_data = message_details.get('raw', '')
                # We decode it to bytes for the flowfile content
                content = base64.urlsafe_b64decode(raw_data)
                attributes["mime.type"] = "message/rfc822"
            else:
                # JSON format
                content = json.dumps(message_details, indent=2)
                attributes["mime.type"] = "application/json"
                
                # Extract some headers for convenience attributes
                payload = message_details.get('payload', {})
                headers = payload.get('headers', [])
                for h in headers:
                    name = h.get('name').lower()
                    if name in ['subject', 'from', 'to', 'date']:
                        attributes[f"email.{name}"] = h.get('value')
                
                snippet = message_details.get('snippet')
                if snippet:
                    attributes["email.snippet"] = snippet

            # Mark as Read if requested
            if mark_read:
                self.service.users().messages().modify(userId='me', id=msg_id, body={'removeLabelIds': ['UNREAD']}).execute()

            return FlowFileSourceResult(relationship="success", attributes=attributes, contents=content)

        except Exception as e:
            self.logger.error(f"Error fetching emails: {str(e)}")
            # We yield to avoid spamming errors
            context.yield_()
            return None

